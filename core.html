<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tensor_tracker.core API documentation</title>
<meta name="description" content="Utility for tracking activations and gradients at `nn.Module` outputs …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tensor_tracker.core</code></h1>
</header>
<section id="section-intro">
<p>Utility for tracking activations and gradients at <code>nn.Module</code> outputs.</p>
<p>Use <code><a title="tensor_tracker.core.track" href="#tensor_tracker.core.track">track()</a></code> to start tracking a module &amp; submodule. Then use the original module
as usual. Your <code><a title="tensor_tracker.core.Tracker" href="#tensor_tracker.core.Tracker">Tracker</a></code> will be filled with a list of <code><a title="tensor_tracker.core.Stash" href="#tensor_tracker.core.Stash">Stash</a></code>es, containing
copies of fwd/bwd tensors at (sub)module outputs. (Beware, this can consume
a lot of memory.)</p>
<p>Usage:</p>
<pre><code>with tensor_tracker.track(model) as tracker:
    model(inputs).backward()

print(list(tracker))
# =&gt; [Stash(name=&quot;0.linear&quot;, type=nn.Linear, grad=False, value=tensor(...)),
#     ...]

display(tracker.to_frame())  # requires 'pandas'
</code></pre>
<p>Advanced usage:</p>
<ul>
<li>
<p>Filter modules based on name:
<code>track(include="&lt;regex&gt;", exclude="&lt;regex&gt;")</code></p>
</li>
<li>
<p>Pre-transform tracked tensors to save memory:
<code>track(stash_value=lambda t: t.std().detach().cpu())</code></p>
</li>
<li>
<p>Customise tracked state:
<code>track(stash=lambda event: ...)</code></p>
</li>
<li>
<p>Manually register/unregister hooks:
<code>tracker = Tracker(); tracker.register(...); tracker.unregister()</code></p>
</li>
</ul>
<p>See also: example of
<a href="example.html">visualising transformer activations &amp; gradients using UMAP</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2023 Graphcore Ltd. All rights reserved.

&#34;&#34;&#34;Utility for tracking activations and gradients at `nn.Module` outputs.

Use `track` to start tracking a module &amp; submodule. Then use the original module
as usual. Your `Tracker` will be filled with a list of `Stash`es, containing
copies of fwd/bwd tensors at (sub)module outputs. (Beware, this can consume
a lot of memory.)

Usage:

```
with tensor_tracker.track(model) as tracker:
    model(inputs).backward()

print(list(tracker))
# =&gt; [Stash(name=&#34;0.linear&#34;, type=nn.Linear, grad=False, value=tensor(...)),
#     ...]

display(tracker.to_frame())  # requires &#39;pandas&#39;
```

Advanced usage:

 - Filter modules based on name:
   `track(include=&#34;&lt;regex&gt;&#34;, exclude=&#34;&lt;regex&gt;&#34;)`

 - Pre-transform tracked tensors to save memory:
   `track(stash_value=lambda t: t.std().detach().cpu())`

 - Customise tracked state:
   `track(stash=lambda event: ...)`

 - Manually register/unregister hooks:
  `tracker = Tracker(); tracker.register(...); tracker.unregister()`

See also: example of
[visualising transformer activations &amp; gradients using UMAP](example.html).
&#34;&#34;&#34;

import dataclasses
import re
from dataclasses import dataclass
from functools import partial
from types import TracebackType
from typing import (
    Any,
    Callable,
    Dict,
    Iterator,
    List,
    Optional,
    Pattern,
    Tuple,
    Type,
    Union,
)

import torch.utils.hooks
from torch import Tensor, nn


@dataclass
class Event:
    name: str
    type: Type[nn.Module]
    grad: bool
    value: Any
    args: Tuple[Any, ...]
    kwargs: Dict[str, Any]


@dataclass
class Stash:
    name: str
    type: Type[nn.Module]
    grad: bool
    value: Any  # output(s) or grad_output(s)

    @property
    def first_value(self) -&gt; Any:
        def _value(v: Any) -&gt; Any:
            if isinstance(v, (tuple, list)) and len(v) &gt;= 1:
                return _value(v[0])
            return v

        return _value(self.value)


StashFn = Callable[[Event], Stash]
StashValueFn = Callable[[Tensor], Any]


def rmap_tensor(value: Any, fn: Callable[[Tensor], Any]) -&gt; Any:
    if isinstance(value, (tuple, list)):
        return type(value)(rmap_tensor(a, fn) for a in value)
    if isinstance(value, dict):
        return {rmap_tensor(k, fn): rmap_tensor(a, fn) for k, a in value.items()}
    if dataclasses.is_dataclass(value):
        return type(value)(**{k: rmap_tensor(v, fn) for k, v in value.__dict__.items()})
    if isinstance(value, Tensor):
        return fn(value)
    return value


def default_stash_value(tensor: Tensor) -&gt; Tensor:
    return tensor.detach().cpu().clone()


def default_stash(event: Event, stash_value: StashValueFn) -&gt; Stash:
    return Stash(
        event.name, event.type, event.grad, rmap_tensor(event.value, stash_value)
    )


def get_stash_fn(
    stash_value: Optional[StashValueFn] = None, stash: Optional[StashFn] = None
) -&gt; StashFn:
    if stash_value and stash:
        raise ValueError(&#34;Cannot provide StashValueFn and StashFn to get_stash_fn()&#34;)
    if stash:
        return stash
    return partial(default_stash, stash_value=stash_value or default_stash_value)


NamePattern = Union[None, Pattern[str], str]


class Tracker:
    def __init__(self, stash: StashFn):
        self.stashes: List[Stash] = []
        self._handles: List[torch.utils.hooks.RemovableHandle] = []
        self._stash = stash

    # Registration/tracking

    def __enter__(self) -&gt; &#34;Tracker&#34;:
        return self

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -&gt; None:
        self.unregister()

    def clear(self) -&gt; None:
        self.stashes.clear()

    def register(self, module: nn.Module, name: str = &#34;&#34;, grad: bool = True) -&gt; None:
        self._handles.append(
            module.register_forward_hook(
                partial(self._forward_hook, name=name), with_kwargs=True
            )
        )
        if grad:
            self._handles.append(
                module.register_full_backward_pre_hook(
                    partial(self._backward_hook, name=name)
                )
            )

    def register_all(
        self,
        module: nn.Module,
        grad: bool = True,
        include: NamePattern = None,
        exclude: NamePattern = None,
    ) -&gt; None:
        include = re.compile(include) if isinstance(include, str) else include
        exclude = re.compile(exclude) if isinstance(exclude, str) else exclude
        for name, child in module.named_modules():
            if ((not include) or include.search(name)) and not (
                exclude and exclude.search(name)
            ):
                self.register(child, name, grad=grad)

    def unregister(self) -&gt; None:
        for handle in self._handles:
            handle.remove()
        self._handles.clear()

    def _forward_hook(
        self,
        module: nn.Module,
        args: Tuple[Any],
        kwargs: Dict[str, Any],
        output: Any,
        *,
        name: str,
    ) -&gt; None:
        self.stashes.append(
            self._stash(Event(name, type(module), False, output, args, kwargs))
        )

    def _backward_hook(self, module: nn.Module, grad_output: Any, *, name: str) -&gt; None:
        self.stashes.append(
            self._stash(Event(name, type(module), True, grad_output, (), {}))
        )

    # Read results

    def __str__(self) -&gt; str:
        return f&#34;Tracker(stashes={len(self)}, tracking={len(self._handles)})&#34;

    def __iter__(self) -&gt; Iterator[Stash]:
        return iter(self.stashes)

    def __getitem__(self, index: int) -&gt; Stash:
        return self.stashes[index]

    def __len__(self) -&gt; int:
        return len(self.stashes)

    def to_frame(
        self, stat: Callable[[Tensor], Tensor] = torch.std
    ) -&gt; &#34;pandas.DataFrame&#34;:  # type:ignore[name-defined] # NOQA: F821
        import pandas

        def to_item(stash: Stash) -&gt; Dict[str, Any]:
            d = stash.__dict__.copy()
            first_value = stash.first_value
            d[&#34;value&#34;] = (
                stat(first_value).item() if isinstance(first_value, Tensor) else None
            )
            d[&#34;type&#34;] = f&#34;{stash.type.__module__}.{stash.type.__name__}&#34;
            return d

        return pandas.DataFrame.from_dict(map(to_item, self))  # type:ignore[arg-type]


def track(
    module: nn.Module,
    grad: bool = True,
    include: NamePattern = None,
    exclude: NamePattern = None,
    stash_value: Optional[StashValueFn] = None,
    stash: Optional[StashFn] = None,
) -&gt; Tracker:
    tracker = Tracker(get_stash_fn(stash_value=stash_value, stash=stash))
    tracker.register_all(module, grad=grad, include=include, exclude=exclude)
    return tracker


track.__doc__ = __doc__

__all__ = [
    &#34;Event&#34;,
    &#34;Stash&#34;,
    &#34;StashFn&#34;,
    &#34;StashValueFn&#34;,
    &#34;rmap_tensor&#34;,
    &#34;default_stash_value&#34;,
    &#34;default_stash&#34;,
    &#34;get_stash_fn&#34;,
    &#34;Tracker&#34;,
    &#34;track&#34;,
]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tensor_tracker.core.default_stash"><code class="name flex">
<span>def <span class="ident">default_stash</span></span>(<span>event: <a title="tensor_tracker.core.Event" href="#tensor_tracker.core.Event">Event</a>, stash_value: Callable[[torch.Tensor], Any]) ‑> <a title="tensor_tracker.core.Stash" href="#tensor_tracker.core.Stash">Stash</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_stash(event: Event, stash_value: StashValueFn) -&gt; Stash:
    return Stash(
        event.name, event.type, event.grad, rmap_tensor(event.value, stash_value)
    )</code></pre>
</details>
</dd>
<dt id="tensor_tracker.core.default_stash_value"><code class="name flex">
<span>def <span class="ident">default_stash_value</span></span>(<span>tensor: torch.Tensor) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_stash_value(tensor: Tensor) -&gt; Tensor:
    return tensor.detach().cpu().clone()</code></pre>
</details>
</dd>
<dt id="tensor_tracker.core.get_stash_fn"><code class="name flex">
<span>def <span class="ident">get_stash_fn</span></span>(<span>stash_value: Optional[Callable[[torch.Tensor], Any]] = None, stash: Optional[Callable[[<a title="tensor_tracker.core.Event" href="#tensor_tracker.core.Event">Event</a>], <a title="tensor_tracker.core.Stash" href="#tensor_tracker.core.Stash">Stash</a>]] = None) ‑> Callable[[<a title="tensor_tracker.core.Event" href="#tensor_tracker.core.Event">Event</a>], <a title="tensor_tracker.core.Stash" href="#tensor_tracker.core.Stash">Stash</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stash_fn(
    stash_value: Optional[StashValueFn] = None, stash: Optional[StashFn] = None
) -&gt; StashFn:
    if stash_value and stash:
        raise ValueError(&#34;Cannot provide StashValueFn and StashFn to get_stash_fn()&#34;)
    if stash:
        return stash
    return partial(default_stash, stash_value=stash_value or default_stash_value)</code></pre>
</details>
</dd>
<dt id="tensor_tracker.core.rmap_tensor"><code class="name flex">
<span>def <span class="ident">rmap_tensor</span></span>(<span>value: Any, fn: Callable[[torch.Tensor], Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_tensor(value: Any, fn: Callable[[Tensor], Any]) -&gt; Any:
    if isinstance(value, (tuple, list)):
        return type(value)(rmap_tensor(a, fn) for a in value)
    if isinstance(value, dict):
        return {rmap_tensor(k, fn): rmap_tensor(a, fn) for k, a in value.items()}
    if dataclasses.is_dataclass(value):
        return type(value)(**{k: rmap_tensor(v, fn) for k, v in value.__dict__.items()})
    if isinstance(value, Tensor):
        return fn(value)
    return value</code></pre>
</details>
</dd>
<dt id="tensor_tracker.core.track"><code class="name flex">
<span>def <span class="ident">track</span></span>(<span>module: torch.nn.modules.module.Module, grad: bool = True, include: Union[ForwardRef(None), Pattern[str], str] = None, exclude: Union[ForwardRef(None), Pattern[str], str] = None, stash_value: Optional[Callable[[torch.Tensor], Any]] = None, stash: Optional[Callable[[<a title="tensor_tracker.core.Event" href="#tensor_tracker.core.Event">Event</a>], <a title="tensor_tracker.core.Stash" href="#tensor_tracker.core.Stash">Stash</a>]] = None) ‑> <a title="tensor_tracker.core.Tracker" href="#tensor_tracker.core.Tracker">Tracker</a></span>
</code></dt>
<dd>
<div class="desc"><p>Utility for tracking activations and gradients at <code>nn.Module</code> outputs.</p>
<p>Use <code><a title="tensor_tracker.core.track" href="#tensor_tracker.core.track">track()</a></code> to start tracking a module &amp; submodule. Then use the original module
as usual. Your <code><a title="tensor_tracker.core.Tracker" href="#tensor_tracker.core.Tracker">Tracker</a></code> will be filled with a list of <code><a title="tensor_tracker.core.Stash" href="#tensor_tracker.core.Stash">Stash</a></code>es, containing
copies of fwd/bwd tensors at (sub)module outputs. (Beware, this can consume
a lot of memory.)</p>
<p>Usage:</p>
<pre><code>with tensor_tracker.track(model) as tracker:
    model(inputs).backward()

print(list(tracker))
# =&gt; [Stash(name=&quot;0.linear&quot;, type=nn.Linear, grad=False, value=tensor(...)),
#     ...]

display(tracker.to_frame())  # requires 'pandas'
</code></pre>
<p>Advanced usage:</p>
<ul>
<li>
<p>Filter modules based on name:
<code>track(include="&lt;regex&gt;", exclude="&lt;regex&gt;")</code></p>
</li>
<li>
<p>Pre-transform tracked tensors to save memory:
<code>track(stash_value=lambda t: t.std().detach().cpu())</code></p>
</li>
<li>
<p>Customise tracked state:
<code>track(stash=lambda event: ...)</code></p>
</li>
<li>
<p>Manually register/unregister hooks:
<code>tracker = Tracker(); tracker.register(...); tracker.unregister()</code></p>
</li>
</ul>
<p>See also: example of
<a href="example.html">visualising transformer activations &amp; gradients using UMAP</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def track(
    module: nn.Module,
    grad: bool = True,
    include: NamePattern = None,
    exclude: NamePattern = None,
    stash_value: Optional[StashValueFn] = None,
    stash: Optional[StashFn] = None,
) -&gt; Tracker:
    tracker = Tracker(get_stash_fn(stash_value=stash_value, stash=stash))
    tracker.register_all(module, grad=grad, include=include, exclude=exclude)
    return tracker</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tensor_tracker.core.Event"><code class="flex name class">
<span>class <span class="ident">Event</span></span>
<span>(</span><span>name: str, type: Type[torch.nn.modules.module.Module], grad: bool, value: Any, args: Tuple[Any, ...], kwargs: Dict[str, Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Event(name: str, type: Type[torch.nn.modules.module.Module], grad: bool, value: Any, args: Tuple[Any, &hellip;], kwargs: Dict[str, Any])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Event:
    name: str
    type: Type[nn.Module]
    grad: bool
    value: Any
    args: Tuple[Any, ...]
    kwargs: Dict[str, Any]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tensor_tracker.core.Event.args"><code class="name">var <span class="ident">args</span> : Tuple[Any, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tensor_tracker.core.Event.grad"><code class="name">var <span class="ident">grad</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tensor_tracker.core.Event.kwargs"><code class="name">var <span class="ident">kwargs</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tensor_tracker.core.Event.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tensor_tracker.core.Event.type"><code class="name">var <span class="ident">type</span> : Type[torch.nn.modules.module.Module]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tensor_tracker.core.Event.value"><code class="name">var <span class="ident">value</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="tensor_tracker.core.Stash"><code class="flex name class">
<span>class <span class="ident">Stash</span></span>
<span>(</span><span>name: str, type: Type[torch.nn.modules.module.Module], grad: bool, value: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Stash(name: str, type: Type[torch.nn.modules.module.Module], grad: bool, value: Any)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Stash:
    name: str
    type: Type[nn.Module]
    grad: bool
    value: Any  # output(s) or grad_output(s)

    @property
    def first_value(self) -&gt; Any:
        def _value(v: Any) -&gt; Any:
            if isinstance(v, (tuple, list)) and len(v) &gt;= 1:
                return _value(v[0])
            return v

        return _value(self.value)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tensor_tracker.core.Stash.grad"><code class="name">var <span class="ident">grad</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tensor_tracker.core.Stash.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tensor_tracker.core.Stash.type"><code class="name">var <span class="ident">type</span> : Type[torch.nn.modules.module.Module]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tensor_tracker.core.Stash.value"><code class="name">var <span class="ident">value</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tensor_tracker.core.Stash.first_value"><code class="name">var <span class="ident">first_value</span> : Any</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_value(self) -&gt; Any:
    def _value(v: Any) -&gt; Any:
        if isinstance(v, (tuple, list)) and len(v) &gt;= 1:
            return _value(v[0])
        return v

    return _value(self.value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tensor_tracker.core.Tracker"><code class="flex name class">
<span>class <span class="ident">Tracker</span></span>
<span>(</span><span>stash: Callable[[<a title="tensor_tracker.core.Event" href="#tensor_tracker.core.Event">Event</a>], <a title="tensor_tracker.core.Stash" href="#tensor_tracker.core.Stash">Stash</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tracker:
    def __init__(self, stash: StashFn):
        self.stashes: List[Stash] = []
        self._handles: List[torch.utils.hooks.RemovableHandle] = []
        self._stash = stash

    # Registration/tracking

    def __enter__(self) -&gt; &#34;Tracker&#34;:
        return self

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -&gt; None:
        self.unregister()

    def clear(self) -&gt; None:
        self.stashes.clear()

    def register(self, module: nn.Module, name: str = &#34;&#34;, grad: bool = True) -&gt; None:
        self._handles.append(
            module.register_forward_hook(
                partial(self._forward_hook, name=name), with_kwargs=True
            )
        )
        if grad:
            self._handles.append(
                module.register_full_backward_pre_hook(
                    partial(self._backward_hook, name=name)
                )
            )

    def register_all(
        self,
        module: nn.Module,
        grad: bool = True,
        include: NamePattern = None,
        exclude: NamePattern = None,
    ) -&gt; None:
        include = re.compile(include) if isinstance(include, str) else include
        exclude = re.compile(exclude) if isinstance(exclude, str) else exclude
        for name, child in module.named_modules():
            if ((not include) or include.search(name)) and not (
                exclude and exclude.search(name)
            ):
                self.register(child, name, grad=grad)

    def unregister(self) -&gt; None:
        for handle in self._handles:
            handle.remove()
        self._handles.clear()

    def _forward_hook(
        self,
        module: nn.Module,
        args: Tuple[Any],
        kwargs: Dict[str, Any],
        output: Any,
        *,
        name: str,
    ) -&gt; None:
        self.stashes.append(
            self._stash(Event(name, type(module), False, output, args, kwargs))
        )

    def _backward_hook(self, module: nn.Module, grad_output: Any, *, name: str) -&gt; None:
        self.stashes.append(
            self._stash(Event(name, type(module), True, grad_output, (), {}))
        )

    # Read results

    def __str__(self) -&gt; str:
        return f&#34;Tracker(stashes={len(self)}, tracking={len(self._handles)})&#34;

    def __iter__(self) -&gt; Iterator[Stash]:
        return iter(self.stashes)

    def __getitem__(self, index: int) -&gt; Stash:
        return self.stashes[index]

    def __len__(self) -&gt; int:
        return len(self.stashes)

    def to_frame(
        self, stat: Callable[[Tensor], Tensor] = torch.std
    ) -&gt; &#34;pandas.DataFrame&#34;:  # type:ignore[name-defined] # NOQA: F821
        import pandas

        def to_item(stash: Stash) -&gt; Dict[str, Any]:
            d = stash.__dict__.copy()
            first_value = stash.first_value
            d[&#34;value&#34;] = (
                stat(first_value).item() if isinstance(first_value, Tensor) else None
            )
            d[&#34;type&#34;] = f&#34;{stash.type.__module__}.{stash.type.__name__}&#34;
            return d

        return pandas.DataFrame.from_dict(map(to_item, self))  # type:ignore[arg-type]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tensor_tracker.core.Tracker.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    self.stashes.clear()</code></pre>
</details>
</dd>
<dt id="tensor_tracker.core.Tracker.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, module: torch.nn.modules.module.Module, name: str = '', grad: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, module: nn.Module, name: str = &#34;&#34;, grad: bool = True) -&gt; None:
    self._handles.append(
        module.register_forward_hook(
            partial(self._forward_hook, name=name), with_kwargs=True
        )
    )
    if grad:
        self._handles.append(
            module.register_full_backward_pre_hook(
                partial(self._backward_hook, name=name)
            )
        )</code></pre>
</details>
</dd>
<dt id="tensor_tracker.core.Tracker.register_all"><code class="name flex">
<span>def <span class="ident">register_all</span></span>(<span>self, module: torch.nn.modules.module.Module, grad: bool = True, include: Union[ForwardRef(None), Pattern[str], str] = None, exclude: Union[ForwardRef(None), Pattern[str], str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_all(
    self,
    module: nn.Module,
    grad: bool = True,
    include: NamePattern = None,
    exclude: NamePattern = None,
) -&gt; None:
    include = re.compile(include) if isinstance(include, str) else include
    exclude = re.compile(exclude) if isinstance(exclude, str) else exclude
    for name, child in module.named_modules():
        if ((not include) or include.search(name)) and not (
            exclude and exclude.search(name)
        ):
            self.register(child, name, grad=grad)</code></pre>
</details>
</dd>
<dt id="tensor_tracker.core.Tracker.to_frame"><code class="name flex">
<span>def <span class="ident">to_frame</span></span>(<span>self, stat: Callable[[torch.Tensor], torch.Tensor] = &lt;built-in method std of type object&gt;) ‑> pandas.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_frame(
    self, stat: Callable[[Tensor], Tensor] = torch.std
) -&gt; &#34;pandas.DataFrame&#34;:  # type:ignore[name-defined] # NOQA: F821
    import pandas

    def to_item(stash: Stash) -&gt; Dict[str, Any]:
        d = stash.__dict__.copy()
        first_value = stash.first_value
        d[&#34;value&#34;] = (
            stat(first_value).item() if isinstance(first_value, Tensor) else None
        )
        d[&#34;type&#34;] = f&#34;{stash.type.__module__}.{stash.type.__name__}&#34;
        return d

    return pandas.DataFrame.from_dict(map(to_item, self))  # type:ignore[arg-type]</code></pre>
</details>
</dd>
<dt id="tensor_tracker.core.Tracker.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister(self) -&gt; None:
    for handle in self._handles:
        handle.remove()
    self._handles.clear()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tensor_tracker" href="index.html">tensor_tracker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tensor_tracker.core.default_stash" href="#tensor_tracker.core.default_stash">default_stash</a></code></li>
<li><code><a title="tensor_tracker.core.default_stash_value" href="#tensor_tracker.core.default_stash_value">default_stash_value</a></code></li>
<li><code><a title="tensor_tracker.core.get_stash_fn" href="#tensor_tracker.core.get_stash_fn">get_stash_fn</a></code></li>
<li><code><a title="tensor_tracker.core.rmap_tensor" href="#tensor_tracker.core.rmap_tensor">rmap_tensor</a></code></li>
<li><code><a title="tensor_tracker.core.track" href="#tensor_tracker.core.track">track</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tensor_tracker.core.Event" href="#tensor_tracker.core.Event">Event</a></code></h4>
<ul class="two-column">
<li><code><a title="tensor_tracker.core.Event.args" href="#tensor_tracker.core.Event.args">args</a></code></li>
<li><code><a title="tensor_tracker.core.Event.grad" href="#tensor_tracker.core.Event.grad">grad</a></code></li>
<li><code><a title="tensor_tracker.core.Event.kwargs" href="#tensor_tracker.core.Event.kwargs">kwargs</a></code></li>
<li><code><a title="tensor_tracker.core.Event.name" href="#tensor_tracker.core.Event.name">name</a></code></li>
<li><code><a title="tensor_tracker.core.Event.type" href="#tensor_tracker.core.Event.type">type</a></code></li>
<li><code><a title="tensor_tracker.core.Event.value" href="#tensor_tracker.core.Event.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tensor_tracker.core.Stash" href="#tensor_tracker.core.Stash">Stash</a></code></h4>
<ul class="">
<li><code><a title="tensor_tracker.core.Stash.first_value" href="#tensor_tracker.core.Stash.first_value">first_value</a></code></li>
<li><code><a title="tensor_tracker.core.Stash.grad" href="#tensor_tracker.core.Stash.grad">grad</a></code></li>
<li><code><a title="tensor_tracker.core.Stash.name" href="#tensor_tracker.core.Stash.name">name</a></code></li>
<li><code><a title="tensor_tracker.core.Stash.type" href="#tensor_tracker.core.Stash.type">type</a></code></li>
<li><code><a title="tensor_tracker.core.Stash.value" href="#tensor_tracker.core.Stash.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tensor_tracker.core.Tracker" href="#tensor_tracker.core.Tracker">Tracker</a></code></h4>
<ul class="">
<li><code><a title="tensor_tracker.core.Tracker.clear" href="#tensor_tracker.core.Tracker.clear">clear</a></code></li>
<li><code><a title="tensor_tracker.core.Tracker.register" href="#tensor_tracker.core.Tracker.register">register</a></code></li>
<li><code><a title="tensor_tracker.core.Tracker.register_all" href="#tensor_tracker.core.Tracker.register_all">register_all</a></code></li>
<li><code><a title="tensor_tracker.core.Tracker.to_frame" href="#tensor_tracker.core.Tracker.to_frame">to_frame</a></code></li>
<li><code><a title="tensor_tracker.core.Tracker.unregister" href="#tensor_tracker.core.Tracker.unregister">unregister</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>